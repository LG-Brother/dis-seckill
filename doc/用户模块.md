# 用户模块接口

## 首页

- 请求地址：/user/index
- 请求方式：get
- 返回响应：login.html

## 登录接口

- 请求地址：/user/login
- 请求方式：post
- 请求参数：

| 请求字段 | 字段含义   | 是否必填 |
| -------- | ---------- | -------- |
| mobile   | 用户手机号 | 必填     |
| password | 密码       | 必填     |

# 商品模块接口

## 商品列表接口

- 请求地址：/goods/goodsList
- 请求方式：get
- 返回响应：goods_list.htm

**工作过程**

1. 客户端发出获取商品列表信息的异步请求；
1. 服务端从缓存中获取商品列表`goods_list.htm`，如果存在，则直接返回给客户端，如果不存在，则进入3；
1. 服务端从商品模块中查询商品列表信息，然后使用`ThymeleafViewResolver`渲染引擎手动渲染商品列表页面，将渲染后的页面数据存储在缓存中，并返回商品列表页面给客户端。

**好处**

上述工作过程对`/goods/goodsList`接口实现了页面级缓存；从redis中取页面，如果没有则需要手动渲染页面，并且将渲染的页面存储在redis中供下一次访问时获取。通过引入缓存，避免每次从数据库中取数据后使用模板渲染html文件，从而省去服务器程序的渲染html文件的不必要工作和的减轻数据库访问压力。

## 商品详情接口

- 请求地址：/goods/getDetails/{goodsId}

- 请求方式：get

- 请求参数：

  | 请求字段 | 字段含义 | 是否必填 |
  | -------- | -------- | -------- |
  | goodsId  | 商品id   | 必填     |

- 返回响应:

  ```json
  {
      "code": 0,
      "msg": "success",
      "data": {
          "seckillStatus": 1,
          "remainSeconds": 0,
          "goods": {
              "id": 1,
              "goodsName": "iphoneX",
              "goodsTitle": "Apple iPhone X (A1865) 64GB 银色 移动联通电信4G手机",
              "goodsImg": "/img/iphonex.png",
              "goodsDetail": "Apple iPhone X (A1865) 64GB 银色 移动联通电信4G手机",
              "goodsPrice": 8765,
              "goodsStock": 10000,
              "seckillPrice": 0.01,
              "stockCount": 9,
              "startDate": "2017-12-04T13:51:23.000+0000",
              "endDate": "2019-12-31T13:51:27.000+0000"
          },
          "user": {
              "uuid": 2,
              "phone": 18342390420,
              "nickname": "Noodle",
              "password": "5e7b3a9754c2777f96174d4ccb980d23",
              "salt": "1a2b3c4d",
              "head": null,
              "registerDate": null,
              "lastLoginDate": null,
              "loginCount": 0
          }
      }
  }
  ```

**工作过程**

1. 客户端发出获取商品详情信息的请求；
1. 服务端通过商品id从商品模块中读取商品详细信息，计算秒杀状态，将秒杀状态和剩余时间以及商品详细信息一并返回给客户端。

# 秒杀模块接口

## 获取验证码接口

- 接口地址：/seckill/verifyCode?goodsId={}

- 请求方式：get

- 请求参数：

  | 请求字段 | 字段含义 | 是否必填 |
  | -------- | -------- | -------- |
  | goodsId  | 商品id   | 必填     |

- 返回响应：验证码图片

**工作过程**

客户端发出获取验证请求，服务端生成验证码图片，并通过response对象返回，通过，将验证码结果存储于缓存中。

## 获取验证码接口

- 接口地址：/seckill/path?goodsId={}&verifyCode={}

- 请求方式：get

- 请求参数：

  | 请求字段   | 字段含义   | 是否必填 |
  | ---------- | ---------- | -------- |
  | goodsId    | 商品id     | 必填     |
  | verifyCode | 验证码结果 | 必填     |

- 返回响应：验证码图片

**工作过程**

1. 客户端获取验证码结果，并将商品id和验证码结果作为请求参数传递到服务端；

2. 服务端获取用户id和商品id，从缓存中查询该用户和该商品下的验证码结果；
2. 比较客户端传递到服务端的验证码结果和缓存中查询出来的验证码结果，如果校验失败，返回非法请求，通过则进入4；
2. 创建随机秒杀地址（MD5随机字符串），并将其存储在缓存中，其key为用户id和商品id的组合，已确定秒杀地址的唯一性。

## 获取秒杀随机地址接口

- 接口地址：/seckill/{path}/doSeckill

- 请求方式：post

- 请求参数：

  | 请求字段 | 字段含义     | 是否必填 |
  | -------- | ------------ | -------- |
  | path     | 随机秒杀地址 | 必填     |
  | goodsId  | 商品id       | 必填     |

- 返回响应：秒杀状态

**工作过程**

1. 以用户id和商品id的组合为键从缓存中读取随机地址，如果随机地址和客户端传入的随机地址不一致，则返回非法请求，如果一致，则进入2；
1. 判断内存中商品是否已秒杀结束，如果结束，则返回秒杀结束标志；
1. 如果判断出秒杀商品未结束则从缓存中预减库存，并在内存中标记商品是否秒杀结束；
1. 从缓存中读取秒杀订单信息，判断是否重复秒杀，如果重复秒杀，则返回重复秒杀提示，如果是第一次秒杀，则进入5；
1. 第4步中可能存在缓存数据已经无效的情形，所以，需要充数据库中读取秒杀订单信息，如果存在记录，则返回重复秒杀提示，如果没有记录，则进入6；
1. 将秒杀请求发送到消息队列中，返回排队提示。客户端继续轮询以获取秒杀结果；
1. 消息队列减库存、下订单、写入秒杀订单。

## 获取秒杀结果接口

- 接口地址：/seckill/result

- 请求方式：GET

- 请求参数：

  | 请求字段 | 字段含义 | 是否必填 |
  | -------- | -------- | -------- |
  | goodsId  | 商品id   | 必填     |

- 返回响应：订单信息

**工作过程**

从订单列表获取秒杀结果，返回给客户端订单信息。































# Redis中存储的数据有：

```properties
# 1. 用户Cookie数据
key: SkUserKeyPrefix_token_{cookie}
value: user信息
# 2. 秒杀用户信息
key: SkUserKeyPrefix_id_{phone}
value: user信息
# 3. 秒杀订单信息
key: OrderKeyPrefix_SK_ORDER_{uuid}_{goodsId}
value: seckillOrder信息
# 4. 商品秒杀结束，在缓存中标记该库存为0
key: SkKeyPrefix_goodsSkOver_{goodsId}
value: true
# 5. 商品列表页缓存
key: GoodsKeyPrefix_goodsListHtml
value: {html}
# 6. 商品库存,过期时间设置为永久不过期
key: GoodsKeyPrefix_goodsStock_{goodsId}
value: {goodsStock}
# 7. 随机秒杀地址，过期时间设置为：1 min
key: SkKeyPrefix_skPath_{userId}_{goodsId}
value: {path}
# 8. 验证码结果，过期时间设置：5 min
key: SkKeyPrefix_verifyResult_{userId}_{goodsId}
value: {verifyResult}
# 9. 防刷拦截，存储用户在过期时间内的访问次数，过期时间为与@AccessLimit上的时间相同
key: AccessKeyPrefix_access_{url}
value: 访问次数
```











## 秒杀请求处理逻辑

秒杀请求url：`/seckill/{path}/doSeckill`

1. 根据userId和goodsId从redis中读取{path}，校验随机秒杀接口地址是否一致，如果不一致，则说明客户端发送的秒杀请求非法，随机秒杀地址被客户端更改。如果一致，则进入2；
1. 系统在启动的时候，已经从数据库中加载所有秒杀商品的库存信息，标记库存的有无到本地内存（HashMap）中和记录具体商品的库存到redis中，所以，这一步在内存标记中判断是否该商品还有库存，如果没有，直接驳回请求，如果有，则进入3；
1. redis中在最开始系统启动时记录了商品的库存信息，所以，可以通过redis预减库存，而不需要在这个时候到db中减库存，如果库存预减到不大于0，表明之前的请求已经将商品库存消耗完成，此时，在内存中标记该商品已经完成秒杀。如果预减库存成功，则将请求放行到4；
1. 根据useId和goodsId从redis中查询秒杀订单信息，如果存在，则说明，该用户已经完成该商品的秒杀，直接驳回请求，否则，放行请求到5；
1. 根据useId和goodsId从数据库中获取订单信息，如果存在，则直接驳回请求，否则放行请求到6；
1. 生成秒杀请求消息，放入队列中，将秒杀请求交由队列处理。

**秒杀请求处理逻辑总结：**

一句话，使用内存标记和缓存将秒杀请求拦截在db上游，防止大并发下的秒杀请求落到db。

为什么有了内存标记，预减库存，订单缓存的情形下，还要在缓存中订单不存在的情况下从db读取订单信息，而在队列中又有从db读取订单信息拦截请求的操作？

**这个问题是由大并发导致的**，实际上，内存标记，可以阻挡一部分请求，然后通过redis预减库存，也只能拦截一部分请求。考虑一种情形：

假设用户以极快的速度同时发出两次请求，两次请求有相同的userId和goodsId，前一次请求完成秒杀时，后一次请求正好从db中读取订单信息，那么可见，后一次请求可以读到完成秒杀的订单，这样就可以将该用户请求拦截下来，不用发送到消息队列中处理，减轻消息队列的负载。

另一种情形，后一次请求没有从数据库中读取到该用户的订单信息，也就是执行时间稍微超前于前一次请求写入订单的时机，那么实际上后一次请求也是无效请求，会发送到消息队列处理，再看消息队列的消费者，消费者也会先从缓存再从db中读取该请求的秒杀订单信息，这样就可以将这个无效请求拦截下来，不用落到db上，达到减轻db负载的压力。

这就是为什么会**两次**从redis中读取订单信息，在redis中订单信息无效时从db读订单信息；一次发生在秒杀请求发送到消息队列之前，一次发生在发送到消息队列之后（即真正做秒杀之前）。目的即使为了阻挡无效的请求落到db上。

redis中存储的随机秒杀地址为：

```properties
key: SkKeyPrefix:skPath_{userId}_{goodsId}
value: {path}
expire: 1 min
```

redis中存储的在系统加载时从db读取的商品库存信息：

```properties
key: GoodsKeyPrefix:goodsStock_{goodsId}
value: {stock}
expire: 0
```



## 消息队列处理秒杀请求的过程（秒杀业务的核心）

1. 消息队列收到秒杀消息（SkMessage[user, goodsId]）后，通过goodsId从DB中查询该商品的库存信息，如果库存不大于0，则直接返回，反之，则表明该商品还有库存，进入2；

1. 通过userId和goodsId从redis中查询秒杀订单信息，如果查询结果不为空，则说明该用户已经对该商品进行过秒杀，直接返回；反之，可能因为缓存有效期的问题，使得缓存中的秒杀订单信息无效，进入3；

1. 根据userId和goodsId从DB中获取秒杀订单信息，如果秒杀订单信息不为空，则说明该用户已经完成该商品的秒杀，直接将秒杀请求驳回，如果查询的秒杀订单信息为空。则说明该用户为对该商品进行过秒杀，进入4；

1. 这一步为秒杀业务逻辑的关键，分为三步：从商品表中减该商品的库存，生成订单信息写入秒杀订单表和订单表中；

1. 首先，减库存。在该商品库存不为零的时候，返回更新记得记录id，大于0则表明更新成，即减库成功；反之，库存为0，减库存失败，在redis中标记该商品已没有库存。

   ```mysql
   UPDATE seckill_goods SET stock_count = stock_count-1 
   WHERE goods_id=#{goodsId} AND stock_count > 0
   ```

1. 如果5中减库存成功，则创建订单，将订单写入秒杀订单表和订单信息表中，并且，将生成的订单信息在db写操作完成后存储到redis中，这样，下次同一用户对同一商品发起秒杀请求时，直接使用redis中的数据就可以判断其完成了秒杀，而不用再从db中读数据判断该用户是否对该商品已经完成了秒杀；

1. 需要注意的是，秒杀动作的关键三步：减库存，生成订单记录插入订单信息表和秒杀订单表构成事务，需要使用Spring的@Transactional注解处理事务。

**消息队列处理秒杀请求的过程总结：**

在秒杀请求中，我们使用大量的缓存将秒杀请求阻挡在db外，真正落入db的请求应该尽可能的小，这样可以防止秒杀请求直接透穿DB，从而减轻db压力。

实际上，秒杀商品有限，库存也有限，如果将秒杀请求直接落到db，是非常不合理的，考虑一种情形，某件秒杀商品的库存为100，在秒杀开始的时候，瞬间的秒杀请求并发量为5W，可以想象，数据库是无法承担如此高的并大量的，另外，5w个秒杀请求，实际只有100个秒杀请求有效，多出来的请求只会无端对数据库造成访问压力，而对业务毫不相关。

消息队列使用redis来拦截秒杀请求，redis中缓存何种数据是非常重要的。详细队列处理秒杀请求时只会从缓存缓存中读写订单信息，写发生在db写订单完成后，读发生在对db写之前。写redis发生在db之后，可以保证缓存和db中的数据的一致性，读redis发生在写db之前，可以用来阻挡无用请求，减轻db压力。

redis中存储的订单信息为：

```properties
key: OrderKeyPrefix:SK_ORDER:{userId}_{goodsId}
value: {SeckillOrder}
expire: 0
```







