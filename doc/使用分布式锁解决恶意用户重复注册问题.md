# 使用分布式锁解决恶意用户重复注册问题

[TOC]

## 问题分析

考虑用户模块下的用户服务实现（`com.seckill.dis.user.service.UserServiceImpl`）：

```java
@Override
public CodeMsg register(RegisterVo userModel) {

    // 检查用户是否注册
    SeckillUser user = this.getSeckillUserByPhone(userModel.getPhone());

    // 用户已经注册
    if (user != null) {
        return CodeMsg.USER_EXIST;
    }

    // 生成skuser对象
	...

    // 写入数据库
    long id = userMapper.insertUser(newUser);

    // 用户注册成功
    if (id > 0)
        return CodeMsg.SUCCESS;

    // 用户注册失败
    return CodeMsg.REGISTER_FAIL;
}
```

显然，这段代码存在线程安全问题，在恶意用户使用注册接口重复写入相同数据的时候，会导致用户数据表中存在重复的数据，这是我们所不希望的。

**实际上，上述问题可以归结为：一次请求和多次请求对资源本身具有同样的结果，也就是说，相同条件下的任意多次执行对资源本身所产生的影响均与一次执行的影响相同，即保证接口的幂等性**。这就是我们需要解决的问题。

## 解决思路

上述问题的解决可以从几个方面入手：

1. 数据库：使用乐观锁、悲观锁或唯一索引；
1. 服务端：加锁。

不管从哪个方面入手，本质的手段都是加锁。

- 使用悲观锁比较简单，使用在`insert`加上`on duplicate key update `即可，这样可以以去重复的方式加锁访问。

- 使用索引也比较简单，对`phone`字段加唯一索引即可。

- 使用乐观锁需要在表上加上一个表示版本的字段。

但是，利用数据库实现锁，会造成大量的请求落在数据库上，并阻塞等待执行，这个过程是需要消耗数据库资源的，使得真正的业务请求得不到处理，在秒杀大并发情形下，可能会导致数据库宕机，数据我们不使用数据库来实现锁，而是在服务端实现锁。

如果只有一个用户服务模块实例，则采用JUC下的`ReentrantLock`重入锁实现即可，或者直接对方法加上`synchronized`，这在单个实例下式没有问题的，也就是单进程的情况。

如果用户服务模块存在多个实例，也就是以集群的方式部署，那么就涉及进程之间的锁问题，`synchronized`和`ReentrantLock`这种单进程的锁只对落到本服务模块的请求有效，而对多进程无效，依旧会有线程安全问题。

这个时候，分布式锁就派上用场了。

## Redis 分布式锁

分布式锁一般有三种实现方式：

1. 数据库乐观锁；
1. 基于Redis的分布式锁；
1. 基于ZooKeeper的分布式锁。

本文将介绍第二种方式，基于Redis实现分布式锁。

首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：

1. 互斥性。在任意时刻，只有一个客户端能持有锁。
1. 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。
1. 具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。
1. 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。